<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day-4</title>
</head>
<body>
    <h1>day 4</h1>
    <pre>
        <h4>q1. What is a Temporal Dead Zone?</h4>

        sol:-  A temporal dead zone (TDZ) is the area of a block where a variable is inaccessible until the moment the computer completely initializes it with a value.

        A block is a pair of braces ({...}) used to group multiple statements.
        Initialization occurs when you assign an initial value to a variable.
        Suppose you attempt to access a variable before its complete initialization. In such a case, JavaScript will throw a ReferenceError.
        
        So, to prevent JavaScript from throwing such an error, you’ve got to remember to access your variables from outside the temporal dead zone.

        <hr>

        <h4>What is the for-in loop in JavaScript? Give its syntax</h4>

        sol:-for in loop is an iteration method for iterating over "enumerable" properties of objects.

        this loop applies to all objects that have these properties.

        here, "enumerable" means an array or object or strings....

        if we are using a for-in loop over an object , it will give us the value to each key in the object.

        <b>ex:- const obj ={
            first: 123,
            second: 523,
            third: 256,
            fourth: 433
        }

        for(const key in obj){
            console.log(obj[key]);
        }</b>

        <hr>


        <h4>Explain Local Scope, Block Scope, Functional Scope and Scope Chain in javascript</h4>

        sol:- ES6 introduced two important new JavaScript keywords: let and const.

        These two keywords provide Block Scope in JavaScript.
        
        Variables declared inside a { } block cannot be accessed from outside the block


        Variables declared with the var keyword can NOT have block scope.

        Variables declared inside a { } block can be accessed from outside the block.


        Local variables have Function Scope:

They can only be accessed from within the function.

Variables defined inside a function are not accessible (visible) from outside the function.

Variables declared with var, let and const are quite similar when declared inside a function.

They all have Function Scope


Variables declared Globally (outside any function) have Global Scope.

Global variables can be accessed from anywhere in a JavaScript program.

Variables declared with var, let and const are quite similar when declared outside a block.


JavaScript engine uses scopes to find out the exact location or accessibility of variables and that particular process is known as Scope Chain.
Scope Chain means that one variable has a scope (it may be global or local/function or block scope) is used by another variable or function having another scope (may be global or local/function or block scope).
This complete chain formation goes on and stops when the user wishes to stop it according to the requirement.

<hr>

<h4>What is difference between null and undefined and where to use what?</h4>

sol:- undefined means a variable has been declared but has not yet been assigned a value.

null is an assignment value. 
it can be assigned to a variable as arepresentation of no value.

<hr>

<h4>what is Symbol?</h4>

sol:-- symbol is a primitive data type of javascript, along with string number, boolean, null and undefined.

it's a very peculiar data type....

once you create a symbol, its value is kept private and for internal use .
symbols are immutable and unique.

<hr>

<h4>Write code to explain map and filter in arrays</h4>

sol:- the map array is used for creating a new array from an existing one, applying a function to each one of the elements of the first array.

<b>
    let arr=[100,200,300]
    let arr1= arr.map(x=> x*2);
    console.log(arr1);
</b>

filter---- 
the filter() method takes each element in array and it applies a conditional statement against it. 
if the condition returns true, then the element gets pushed to the output array .. 
if the condition returns false, the element does not get pushed to the output array.

<b>
    let arr= [100,200,300],
    let arr1= arr.filter(x=> (x>100));
    console.log(arr);
</b>

<hr>

<h4>Explain passed by value and passed by reference</h4>

sol:-- in pass by value in JavaScript, a copy of the original variable is created so any changes made to the copied variable do not affect the original variable. In pass by reference in JavaScript, we pass the reference of the actual parameter. No copy is created in the memory. 

<hr>

<h4>Please explain Self Invoking Function and its code</h4>

sol:-  a self involking expression is involked automatically, without being called..

function expressions will execute automatically if the expression is followed by ().

you cannot self involk a function declaration.

you have to add parantheses around the function to indicate that it is a function expression.

<b>
    (function(){
        let x ="hello";
    })
</b>

<hr>


<h4>What is an event loop and call stack</h4>

sol:-  The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all operations on a single thread, but using a few smart data structures, it gives us the illusion of multi-threading. Let’s take a look at what happens on the back-end.

The call stack is responsible for keeping track of all the operations in line to be executed. Whenever a function is finished, it is popped from the stack.

The event queue is responsible for sending new functions to the stack for processing. It follows the queue data structure to maintain the correct sequence in which all operations should be sent for execution.
</pre>
</body>
</html>